C51 COMPILER V7.01  WINDOW                                                                 12/06/2014 17:38:54 PAGE 1   


C51 COMPILER V7.01, COMPILATION OF MODULE WINDOW
OBJECT MODULE PLACED IN window.OBJ
COMPILER INVOKED BY: C:\GreenTools\Keil\C51\BIN\C51.EXE window.c LARGE OPTIMIZE(SIZE) BROWSE DEBUG OBJECTEXTEND

stmt level    source

   1          #include "window.h"
   2          #include "lcd.h"
   3          //#include "stdio.h"
   4          #include "stdlib.h"
   5          //#include "sjDefine.h"
   6          MSG_HANDLER curr_window = 0;             
   7          
   8          
   9          extern uchar pos_databuf;     
  10          extern uchar data_sign;
  11          extern u8 databuf[12];
  12          
  13          /*¼ÆËã×Ö·û´®³¤¶È*/
  14          uchar strlen(uchar *s)
  15          {
  16   1              uchar len = 0;
  17   1              while(*s++) len ++;
  18   1              
  19   1              return len;
  20   1      }
  21          
  22          double buf2double()      
  23          {                  
  24   1              return atof(databuf);
  25   1              /*
  26   1         double tmp = 0.0;
  27   1         uchar i = 0;
  28   1         uchar pos = 0;
  29   1         for(i=1;i<pos_databuf;i++) {
  30   1            if(databuf[i] != KEY_DOT)
  31   1               tmp = tmp * 10.0+(databuf[i] - '0');
  32   1            else
  33   1               pos = pos_databuf - i - 2;
  34   1         }
  35   1         while(pos > 0) {
  36   1            tmp = tmp / 10.0;
  37   1            pos--;
  38   1         }                                        
  39   1         if(data_sign == 1)
  40   1                 tmp = -tmp;
  41   1                return tmp;
  42   1                */
  43   1      }
  44          int buf2byte()       //convert rundata.tempbuf to byte (00-99)
  45          {       
  46   1              return atoi(databuf);
  47   1              /*
  48   1         int tmp = 0;
  49   1         uchar i;
  50   1         for(i=0;i<pos_databuf;i++) {
  51   1            tmp = tmp * 10+(databuf[i] - '0');
  52   1         }
  53   1         return tmp;
  54   1         */
  55   1      }
C51 COMPILER V7.01  WINDOW                                                                 12/06/2014 17:38:54 PAGE 2   

  56          
  57          
  58          
  59          extern uchar key;
  60          u8 strbuf[12];
  61          u8 databuf[12];
  62          u8 pos_databuf; //position in data buffer
  63          u8 max_databuf;
  64          u8 data_sign;   // sign of the data
  65          LABEL code datalbl = {LBL_HZ16,10,10,8,strbuf};
  66          LABEL code datalbl2 = {LBL_HZ6X8,140,54,8,"UP:+/-,DN:'E'"};
  67          LABEL code datalbl3 = {LBL_HZ6X8,140,54,8,"UP/DN:'A'-'Z'"};
  68          LABEL code databox = {LBL_HZ16,20,30,9,databuf};
  69          
  70          
  71          uchar wnd_intinput(uchar lastval)
  72          {
  73   1              uchar msg;
  74   1              
  75   1              key = MSG_INIT;
  76   1              databuf[0] = '\0';
  77   1              pos_databuf = 0;
  78   1              data_sign = 0;  
  79   1              while(1)
  80   1              {
  81   2                      if(key != KEY_INVALID)
  82   2                      {
  83   3                              msg = key;
  84   3                              
  85   3                      }else{
  86   3                              continue;
  87   3                      }
  88   2                      if(msg == MSG_INIT)
  89   2                      {
  90   3                              LCD_Cls();
  91   3                              draw_label(&datalbl,SW_NORMAL);
  92   3                              draw_inputbox(&databox);
  93   3      //                      LCD_ShowCursor(databox.x,databox.y);
  94   3      
  95   3                      }
  96   2      
  97   2                      if(msg == KEY_TAB)
  98   2                      {
  99   3                      /*
 100   3                              if(pos_databuf < max_databuf)
 101   3                              {
 102   3                                      databuf[pos_databuf++] = '0';
 103   3                                      databuf[pos_databuf] = '\0';
 104   3                                      msg = MSG_REFRESH;
 105   3                              }
 106   3                      */
 107   3                      }
 108   2                      
 109   2                      if(msg == KEY_DN) {
 110   3                      /*
 111   3                              if(pos_databuf == 0)
 112   3                              {
 113   3                                      databuf[pos_databuf++] = '0';
 114   3                                      databuf[pos_databuf] = '\0';
 115   3                              }
 116   3      
 117   3                              if(databuf[pos_databuf-1] == '0')
C51 COMPILER V7.01  WINDOW                                                                 12/06/2014 17:38:54 PAGE 3   

 118   3                                      databuf[pos_databuf-1] = '9';
 119   3                              else
 120   3                                      databuf[pos_databuf-1] -= 1;
 121   3                              msg = MSG_REFRESH;
 122   3                      */
 123   3                      }
 124   2                      if(msg == KEY_UP) {
 125   3                      /*
 126   3                              if(pos_databuf == 0)
 127   3                              {
 128   3                                      databuf[pos_databuf++] = '0';
 129   3                                      databuf[pos_databuf] = '\0';
 130   3                              }
 131   3      
 132   3                              if(databuf[pos_databuf-1] == '9')
 133   3                                      databuf[pos_databuf-1] = '0';
 134   3                              else
 135   3                                      databuf[pos_databuf-1] += 1;
 136   3                              msg = MSG_REFRESH;
 137   3                      */
 138   3                      }
 139   2                      if(msg >= KEY_NUM0 && msg <= KEY_NUM9) {
 140   3                              if(pos_databuf < max_databuf)
 141   3                              {
 142   4                                      databuf[pos_databuf++] = msg;
 143   4                                      databuf[pos_databuf] = '\0';
 144   4                                      msg = MSG_REFRESH;
 145   4                              }
 146   3                      }
 147   2                      if(msg == KEY_CE) {
 148   3      //                      LCD_HideCursor();
 149   3                              key = KEY_INVALID;
 150   3                              return lastval;
 151   3                      }
 152   2                      if(msg == KEY_OK){
 153   3      //                      LCD_HideCursor();
 154   3                              key = KEY_INVALID;
 155   3                              return buf2byte();
 156   3                      }
 157   2                      if(msg == MSG_REFRESH) {
 158   3                              draw_label(&databox,SW_NORMAL);
 159   3      //                      LCD_ShowCursor(databox.x+pos_databuf*16,databox.y);
 160   3                      }       
 161   2                      key = KEY_INVALID;
 162   2              }
 163   1      }
 164          double wnd_floatinput(double lastval)
 165          {
 166   1              uchar msg;
 167   1      
 168   1              databuf[0] = '+';
 169   1              databuf[1] = '\0';
 170   1              pos_databuf = 1;
 171   1              data_sign = 0;  
 172   1              key = MSG_INIT;
 173   1              while(1)
 174   1              {
 175   2                      if(key != KEY_INVALID)
 176   2                      {
 177   3                              msg = key;
 178   3              
 179   3                      }else{
C51 COMPILER V7.01  WINDOW                                                                 12/06/2014 17:38:54 PAGE 4   

 180   3                              continue;
 181   3                      }
 182   2                      if(msg == MSG_INIT)
 183   2                      {
 184   3                              LCD_Cls();
 185   3                              draw_label(&datalbl,SW_NORMAL);
 186   3                              draw_label(&datalbl2,SW_NORMAL);                        
 187   3                              draw_inputbox(&databox);
 188   3      //                      LCD_ShowCursor(databox.x,databox.y);
 189   3                      }
 190   2      
 191   2                      if(msg == KEY_TAB)
 192   2                      {                                          
 193   3                              msg = MSG_REFRESH;
 194   3                      }
 195   2                      if(msg == KEY_UP) {                                
 196   3                              if(pos_databuf == 1)
 197   3                              {              
 198   4                                      if((data_sign & 0x01) == 0)      //no sign
 199   4                                      {
 200   5                                              databuf[0] = '-';
 201   5                                              data_sign |= 0x01;
 202   5                                      }else{
 203   5                                              databuf[0] = '+';       //
 204   5                                              data_sign ^= 0x01;
 205   5                                      }
 206   4                              }else{
 207   4                                      if((pos_databuf < max_databuf) && (databuf[pos_databuf-2] == 'E'))
 208   4                                      {                          
 209   5                                              if((data_sign & 0x08) == 0)         
 210   5                                              {
 211   6                                                      databuf[pos_databuf-1] = '-';
 212   6                                                      data_sign |= 0x08;
 213   6                                              }else{
 214   6                                                      databuf[pos_databuf-1] = '+';
 215   6                                                      data_sign ^= 0x08;
 216   6                                              }
 217   5                                      }        
 218   4                                      msg = MSG_REFRESH;
 219   4                              }
 220   3                              msg = MSG_REFRESH;
 221   3                      }
 222   2                      if(msg == KEY_DN) {
 223   3                              if((pos_databuf < max_databuf) && ((data_sign & 0x04) == 0))    //no E in string
 224   3                              {
 225   4                                      databuf[pos_databuf++] = 'E';
 226   4                                      databuf[pos_databuf++] = '+';
 227   4                                      databuf[pos_databuf] = '\0';                      
 228   4                                      data_sign |= 0x04;
 229   4                                      msg = MSG_REFRESH;
 230   4                              }
 231   3                      
 232   3                              msg = MSG_REFRESH;
 233   3                      }                                      
 234   2                      if( msg == KEY_DOT)
 235   2                      {
 236   3                              if((pos_databuf < max_databuf) && ((data_sign & 0x02) == 0))      //no dot in string
 237   3                              {
 238   4                                      databuf[pos_databuf++] = msg;
 239   4                                      databuf[pos_databuf] = '\0';                      
 240   4                                      data_sign |= 0x02;
 241   4                                      msg = MSG_REFRESH;
C51 COMPILER V7.01  WINDOW                                                                 12/06/2014 17:38:54 PAGE 5   

 242   4                              }
 243   3      
 244   3                      }
 245   2                      if((msg >= KEY_NUM0 && msg <= KEY_NUM9)) {
 246   3                              if(pos_databuf < max_databuf)
 247   3                              {
 248   4                                      databuf[pos_databuf++] = msg;
 249   4                                      databuf[pos_databuf] = '\0';
 250   4                                      msg = MSG_REFRESH;
 251   4                              }
 252   3                      }
 253   2                      if(msg == KEY_CE) {
 254   3      //                      LCD_HideCursor();
 255   3                      key = KEY_INVALID;
 256   3                              return lastval;
 257   3                      }
 258   2                      if(msg == KEY_OK){
 259   3                                      key = KEY_INVALID;
 260   3      //                      LCD_HideCursor();
 261   3                              return buf2double();
 262   3                      }
 263   2                      if(msg == MSG_REFRESH) {
 264   3                              draw_label(&databox,SW_NORMAL);
 265   3      //                      LCD_ShowCursor(databox.x+pos_databuf*16,databox.y);
 266   3                      }                                 
 267   2                                      key = KEY_INVALID;
 268   2              }
 269   1      }
 270          //display a message box
 271          void wnd_msgbox(LABEL *lbl)
 272          {
 273   1              LCD_ClsBlock(lbl->x - 10,lbl->y - 3,lbl->x + lbl->width * 16 -14 , lbl->y+19);
 274   1              draw_label(lbl, SW_NORMAL);     
 275   1              LCD_Rectange(lbl->x - 10,lbl->y - 3,lbl->x + lbl->width * 16 -14, lbl->y+19);
 276   1              LCD_Rectange(lbl->x - 8,lbl->y - 1,lbl->x + lbl->width * 16 - 16 , lbl->y+17);
 277   1      
 278   1      }
 279          
 280          void draw_inputbox(LABEL *lbl)
 281          {
 282   1              LCD_ClsBlock(lbl->x - 10,lbl->y - 3,lbl->x + lbl->width * 16 , lbl->y+19);
 283   1              LCD_Rectange(lbl->x - 10,lbl->y - 3,lbl->x + lbl->width * 16 , lbl->y+19);
 284   1              draw_label(lbl, SW_NORMAL);     
 285   1      }
 286          
 287          void draw_label(LABEL *lbl,uchar reverse) {
 288   1              uchar len = lbl->width;
 289   1              if(lbl->type == LBL_HZ6X8) {
 290   2                      if(reverse & SW_NORMAL) {
 291   3                              if((reverse & SW_OVERLAP) == 0)
 292   3                                      LCD_ClsBlock( lbl->x, lbl->y, lbl->x + (len<<3), lbl->y + 8);
 293   3                              LCD_Print6X8( lbl->x, lbl->y, lbl->param);
 294   3                              return;                 
 295   3                      }
 296   2                      if(reverse & SW_REVERSE)
 297   2                              LCD_ReverseRect(lbl->x, lbl->y, len , 8);
 298   2                      return;
 299   2              }
 300   1              if(lbl->type == LBL_HZ8X16) {
 301   2                      if(reverse & SW_NORMAL) {
 302   3                              if((reverse & SW_OVERLAP) == 0)
 303   3                                      LCD_ClsBlock( lbl->x, lbl->y, lbl->x + (len<<3), lbl->y + 16);
C51 COMPILER V7.01  WINDOW                                                                 12/06/2014 17:38:54 PAGE 6   

 304   3                              LCD_Print8X16( lbl->x, lbl->y, lbl->param);
 305   3                              return;
 306   3                      }
 307   2                      if(reverse & SW_REVERSE)
 308   2                              LCD_ReverseRect(lbl->x, lbl->y, len * 1, 16);
 309   2                      return;
 310   2              }
 311   1              /*
 312   1              if(lbl->type == LBL_HZ24X32) {
 313   1                      if(reverse & SW_NORMAL) {
 314   1                              if((reverse & SW_OVERLAP) == 0)
 315   1                                      LCD_ClsBlock( lbl->x, lbl->y, lbl->x + len * 24, lbl->y + 32);
 316   1                              LCD_Print24X32( lbl->x, lbl->y, lbl->param);
 317   1                      }
 318   1                      if(reverse & SW_REVERSE)
 319   1                              LCD_ReverseRect(lbl->x, lbl->y, len * 3, 32);
 320   1                      return;
 321   1              }
 322   1              */
 323   1              if(lbl->type == LBL_HZ12) {
 324   2                      if(reverse & SW_NORMAL) {
 325   3                              if((reverse & SW_OVERLAP) == 0)
 326   3                                      LCD_ClsBlock( lbl->x, lbl->y, lbl->x + (len<<4), lbl->y + 12);
 327   3                              LCD_PrintHz12( lbl->x, lbl->y, lbl->param);
 328   3                      }
 329   2                      if(reverse & SW_REVERSE)
 330   2                              LCD_ReverseRect(lbl->x, lbl->y, len * 2, 12);
 331   2                      return;
 332   2              }
 333   1              if(lbl->type == LBL_HZ16) {
 334   2                      if(reverse & SW_NORMAL) {
 335   3                              if((reverse & SW_OVERLAP) == 0)
 336   3                                      LCD_ClsBlock( lbl->x, lbl->y, lbl->x + (len<<4), lbl->y + 16);
 337   3                              LCD_PrintHz16( lbl->x, lbl->y, lbl->param);
 338   3                      }
 339   2                      if(reverse & SW_REVERSE)
 340   2                              LCD_ReverseRect(lbl->x, lbl->y, len * 2, 16);
 341   2                      return;
 342   2              }
 343   1      }
 344          
 345          


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   1736    ----
   CONSTANT SIZE    =     72    ----
   XDATA SIZE       =     30      18
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)

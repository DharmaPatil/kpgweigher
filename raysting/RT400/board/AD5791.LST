C51 COMPILER V7.01  AD5791                                                                 12/06/2014 17:38:54 PAGE 1   


C51 COMPILER V7.01, COMPILATION OF MODULE AD5791
OBJECT MODULE PLACED IN AD5791.OBJ
COMPILER INVOKED BY: C:\GreenTools\Keil\C51\BIN\C51.EXE AD5791.c LARGE OPTIMIZE(SIZE) BROWSE DEBUG OBJECTEXTEND

stmt level    source

   1          /********************************************************************************
   2           Author : CAC (China Applications Support Team) 
   3          
   4           Date :   January, 2012
   5          
   6           File name :   AD5791.c
   7          
   8           Description :   Use the GPIO to simulate the SPI communication of AD5791
   9          
  10           Hardware plateform :   AD5791 and AD5791
  11          ********************************************************************************/
  12          
  13          //#include "AD5791.h"
  14          //#include "AD5791Driver.h"
  15          #include "AD5791.h"
  16          #include "stdio.h"
  17          #include "math.h"
  18          extern void swiDelay(unsigned char dl1,unsigned char dl2);
  19          
  20          xdata unsigned long int AD5791Registers[5]={0,0,0,0,0};         // only low 24 bits are used for each register
  21          
  22          unsigned char *dacbuf;
  23          unsigned char *clrbuf;
  24          
  25          unsigned char ch_dummy;
  26          
  27          #define AD5791OutputBit(A,B)    A=B;
  28          
  29          #define AD5791DelayUs(i)        swiDelay(1,i);
  30          
  31          #define AD5791InputBit(A)  (A) 
  32          
  33          unsigned char AD5791SpiRead(unsigned char WriteData)
  34          {
  35   1               unsigned   char   ReadData;
  36   1           unsigned   char  j;
  37   1      
  38   1        
  39   1      
  40   1            ReadData = 0;
  41   1      
  42   1            for(j=0; j<8; j++)
  43   1            {
  44   2               AD5791OutputBit(SCLK,1);
  45   2      
  46   2               if(0x80 == (WriteData & 0x80))
  47   2               {
  48   3                  AD5791OutputBit(SDI,1);     //Send one to SDI pin
  49   3               }
  50   2               else
  51   2               {
  52   3                  AD5791OutputBit(SDI,0);     //Send zero to SDI pin
  53   3               }
  54   2               WriteData = WriteData << 1;
  55   2               ReadData = (ReadData<<1) | AD5791InputBit(SDO); 
C51 COMPILER V7.01  AD5791                                                                 12/06/2014 17:38:54 PAGE 2   

  56   2      
  57   2               AD5791OutputBit(SCLK,0);   /////
  58   2      
  59   2            }
  60   1            return ReadData;
  61   1      }
  62          void AD5791SpiWrite(unsigned char WriteData)
  63          {
  64   1           unsigned   char   j;
  65   1      
  66   1      
  67   1            for(j=0; j<8; j++)
  68   1            {
  69   2               AD5791OutputBit(SCLK,1);
  70   2      
  71   2               if(0x80 == (WriteData & 0x80))
  72   2               {
  73   3                  AD5791OutputBit(SDI,1);     //Send one to SDI pin
  74   3               }
  75   2               else
  76   2               {
  77   3                  AD5791OutputBit(SDI,0);     //Send zero to SDI pin
  78   3               }
  79   2               WriteData = WriteData << 1;
  80   2      
  81   2               AD5791OutputBit(SCLK,0);   /////
  82   2            }
  83   1      }
  84             // clear code is set to 0x0007ffff; since we enabled buffer function
  85          #define MYCLR_CODE      0x0007ffff
  86          #define CONFIG_MODE     RBUF_ON|OPGND_DIS|DACTRI_DIS|BIN_2SC_BIN|SDO_EN|LIN_COMP_10
  87          
  88          void AD5791Init()
  89          {
  90   1         /* initialize the GPIOs for controlling the AD5791*/
  91   1         AD5791OutputBit(LDAC, 1);
  92   1         AD5791OutputBit(SYNC, 1);
  93   1         AD5791OutputBit(CLR, 1);
  94   1         AD5791OutputBit(SCLK, 1);
  95   1         AD5791OutputBit(SDI, 1);
  96   1         ch_dummy = AD5791InputBit(SDO);
  97   1      
  98   1      
  99   1              dacbuf = (unsigned char*)(AD5791Registers + DAC_VALUE);
 100   1              clrbuf = (unsigned char*)(AD5791Registers + CLEARCODE);
 101   1      
 102   1              AD5791Initialization();
 103   1              swiDelay(0x0f,0xff);
 104   1      
 105   1              AD5791Registers[CONTROL] = CONFIG_MODE;
 106   1              WriteToAD5791ViaSPI(CONTROL, AD5791Registers);
 107   1      
 108   1              AD5791Registers[CLEARCODE] = MYCLR_CODE;        
 109   1              WriteToAD5791ViaSPI(CLEARCODE, AD5791Registers);
 110   1      
 111   1              AD5791Registers[DAC_VALUE] = MYCLR_CODE;        
 112   1              WriteToAD5791ViaSPI(DAC_VALUE, AD5791Registers);
 113   1              AD5791HardwareLoad();   
 114   1              AD5791Registers[CONTROL] = 0;
 115   1              AD5791Registers[CLEARCODE] = MYCLR_CODE;
 116   1      
 117   1      }
C51 COMPILER V7.01  AD5791                                                                 12/06/2014 17:38:54 PAGE 3   

 118          
 119          void AD5791HardwareReset()
 120          {
 121   1              AD5791OutputBit(RESET,0);
 122   1              AD5791OutputBit(RESET,1);
 123   1              AD5791DelayUs(10);
 124   1      }
 125          
 126          void AD5791HardwareClear()
 127          {
 128   1              AD5791OutputBit(CLR,0);
 129   1              AD5791OutputBit(CLR,1);
 130   1      }
 131          
 132          void AD5791HardwareLoad()
 133          {
 134   1              AD5791OutputBit(LDAC,0);
 135   1              AD5791OutputBit(LDAC,1);
 136   1      }
 137          
 138          void AD5791Initialization()
 139          {
 140   1              AD5791HardwareReset();
 141   1              AD5791HardwareClear();
 142   1      }
 143          
 144          void WriteToAD5791ViaSPI(unsigned char RegisterStartAddress, unsigned long int *DataBuffer)
 145          {
 146   1              unsigned char  WriteData;
 147   1              
 148   1      
 149   1         AD5791OutputBit(SYNC,0);
 150   1         AD5791OutputBit(SCLK,1); 
 151   1      
 152   1                      WriteData = ((RegisterStartAddress)<<4) | (DataBuffer[RegisterStartAddress]>>16);
 153   1                      AD5791SpiWrite(WriteData);
 154   1                      WriteData = DataBuffer[RegisterStartAddress]>>8;
 155   1                      AD5791SpiWrite(WriteData);
 156   1                      WriteData = DataBuffer[RegisterStartAddress];
 157   1                      AD5791SpiWrite(WriteData);
 158   1      
 159   1         AD5791OutputBit(SCLK,1);
 160   1         AD5791OutputBit(SYNC,1);
 161   1      }
 162          
 163          void ReadFromAD5791ViaSPI(const unsigned char RegisterStartAddress,unsigned char *DataBuffer)
 164          {
 165   1              unsigned char  WriteData;
 166   1      
 167   1              AD5791OutputBit(SYNC,0);
 168   1              AD5791OutputBit(SCLK,1); 
 169   1      
 170   1              WriteData = 0x80 | ((RegisterStartAddress)<<4) ;        
 171   1              AD5791SpiWrite(WriteData);
 172   1              AD5791SpiWrite(NOP);
 173   1              AD5791SpiWrite(NOP);
 174   1              AD5791OutputBit(SCLK,1);
 175   1              AD5791OutputBit(SYNC,1);
 176   1      
 177   1              AD5791OutputBit(SCLK,0);
 178   1              AD5791OutputBit(SYNC,0);
 179   1      
C51 COMPILER V7.01  AD5791                                                                 12/06/2014 17:38:54 PAGE 4   

 180   1              DataBuffer[0] = 0x00;
 181   1              DataBuffer[1] = 0x0f & AD5791SpiRead(NOP);
 182   1              DataBuffer[2] = AD5791SpiRead(NOP);
 183   1              DataBuffer[3] = AD5791SpiRead(NOP);
 184   1      
 185   1              AD5791OutputBit(SYNC,1);
 186   1              AD5791OutputBit(SCLK,1);
 187   1      
 188   1      }
 189          
 190          
 191          unsigned long lastd = 0;
 192          unsigned char cm_ad5791(unsigned char temp, double val)  //crc b1 b2 b3 func
 193          {
 194   1              unsigned long d; //32bit
 195   1      
 196   1                                                      if(temp == DACMD_OUTPUT)
 197   1                                                      {
 198   2                                                              d = floor(0.5+val*(1048576 - 1) / 10.0);
 199   2                                                              if( d == lastd)
 200   2                                                              {
 201   3                                                                      temp = 1;
 202   3                                                              }else
 203   2                                                              {
 204   3                                                                      dacbuf[0] = (*((unsigned char*)(&d)+0));
 205   3                                                                      dacbuf[1] = (*((unsigned char*)(&d)+1));
 206   3                                                                      dacbuf[2] = (*((unsigned char*)(&d)+2));
 207   3                                                                      dacbuf[3] = (*((unsigned char*)(&d)+3));
 208   3                                                                      WriteToAD5791ViaSPI(DAC_VALUE, AD5791Registers);
 209   3                                                                      AD5791HardwareLoad();
 210   3                                                                      swiDelay(0x0f,0xff);
 211   3                                                                      AD5791Registers[CLEARCODE] = 0;
 212   3                                                                      ReadFromAD5791ViaSPI(DAC_VALUE, clrbuf);
 213   3                                                                      temp = 0;
 214   3                                                                      if(AD5791Registers[CLEARCODE] == AD5791Registers[DAC_VALUE])
 215   3                                                                              temp = 1;
 216   3                                                              }
 217   2                                                      }
 218   1                                                      else if(temp == DACMD_HWCLR)
 219   1                                                      {
 220   2                                                              AD5791HardwareClear();
 221   2                                                              temp = 1;
 222   2                                                      }
 223   1                                                      else if(temp == DACMD_HWRST)
 224   1                                                      {
 225   2                                                              AD5791HardwareReset();
 226   2                                                              temp = 1;
 227   2                                                      }
 228   1                                                      else if(temp ==DACMD_RESCUE)
 229   1                                                      {
 230   2                                                              AD5791Registers[CONTROL] = CONFIG_MODE;
 231   2                                                              WriteToAD5791ViaSPI(CONTROL, AD5791Registers);
 232   2      
 233   2                                                              AD5791Registers[CLEARCODE] = MYCLR_CODE;        // clear code is set to 0
 234   2                                                              WriteToAD5791ViaSPI(CLEARCODE, AD5791Registers);
 235   2      
 236   2                                                              AD5791Registers[CONTROL] = 0;
 237   2                                                              AD5791Registers[CLEARCODE] = MYCLR_CODE;
 238   2                                                              temp = 1;
 239   2                                                      }
 240   1                                                      else if(temp == 0x05)
 241   1                                                      {
C51 COMPILER V7.01  AD5791                                                                 12/06/2014 17:38:54 PAGE 5   

 242   2      /*
 243   2                                                              AD5791Registers[CLEARCODE] = 0;
 244   2                                                              ReadFromAD5791ViaSPI(CONTROL, clrbuf);
 245   2                                                              sjSerialSendByte(clrbuf[0]);
 246   2                                                              sjSerialSendByte(clrbuf[1]);
 247   2                                                              sjSerialSendByte(clrbuf[2]);
 248   2                                                              sjSerialSendByte(clrbuf[3]);
 249   2      
 250   2                                                              AD5791Registers[CLEARCODE] = 0;
 251   2                                                              ReadFromAD5791ViaSPI(DAC_VALUE, clrbuf);
 252   2                                                              sjSerialSendByte(clrbuf[0]);
 253   2                                                              sjSerialSendByte(clrbuf[1]);
 254   2                                                              sjSerialSendByte(clrbuf[2]);
 255   2                                                              sjSerialSendByte(clrbuf[3]);
 256   2      */
 257   2                                                              temp = 1;
 258   2                                                      }
 259   1                                                      else{
 260   2                                                              temp = 0;
 261   2                                                      }
 262   1                                              
 263   1                                              return temp;
 264   1      }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    746    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =     31      13
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)

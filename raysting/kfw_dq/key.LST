C51 COMPILER V7.01  KEY                                                                    08/21/2009 20:36:18 PAGE 1   


C51 COMPILER V7.01, COMPILATION OF MODULE KEY
OBJECT MODULE PLACED IN key.OBJ
COMPILER INVOKED BY: F:\GreenTools\Keil\C51\BIN\C51.EXE key.c BROWSE DEBUG OBJECTEXTEND

stmt level    source

   1              #include <stc51.h>
   2                  #include <stdio.h>
   3                  #include <intrins.h>
   4                  #include <MATH.H>
   5                  #include "utili.h"
   6                  #include "key.h"
   7                  #define uchar unsigned char
   8                  #define uint unsigned int
   9                  #define ulong unsigned long
  10                  #define KEYTIMEOUT      1
  11          
  12              sbit l9= P3^6;   //定义时钟端164
  13          
  14                  bit  KEYBJ2     ;       //KEY_DOWN event
  15              uchar keykeep;
  16                  uint  keycount; //delay counter
  17          
  18                  sbit kbit = P3^2; //key int
  19          extern uchar key;
  20          void decode_key()
  21          {
  22   1         uchar k;
  23   1         P1 = 0x0F;l9=1;//低位置○，准备查询按键
  24   1         k  = P1;       //取得当前P1口的状态
  25   1        
  26   1         if(k != 0x0F)
  27   1         {//如果有变化则表示有键按下
  28   2           k = 0xef;
  29   2         do{//循环扫描每一行
  30   3           P1 = k;
  31   3           if(k != P1)
  32   3           {
  33   4           switch(P1)
  34   4             {
  35   5            //第一行
  36   5            case 0x77:{keykeep=KEY_OK;break;}
  37   5            case 0xb7:{keykeep=KEY_CE;break;}
  38   5            case 0xd7:{keykeep=KEY_NUM0;break;}
  39   5            case 0xe7:{keykeep=KEY_DOT;break;}
  40   5            //第二行
  41   5            case 0x7b:{keykeep=KEY_DN;break;}
  42   5            case 0xbb:{keykeep=KEY_NUM3;break;}
  43   5            case 0xdb:{keykeep=KEY_NUM2;break;}
  44   5            case 0xeb:{keykeep=KEY_NUM1;break;}
  45   5            //第三行
  46   5            case 0x7d:{keykeep=KEY_UP;break;}
  47   5            case 0xbd:{keykeep=KEY_NUM6;break;}
  48   5            case 0xdd:{keykeep=KEY_NUM5;break;}
  49   5            case 0xed:{keykeep=KEY_NUM4;break;}
  50   5            //第四行
  51   5            case 0x7e:{keykeep=KEY_TAB;break;}
  52   5            case 0xbe:{keykeep=KEY_NUM9;break;}
  53   5            case 0xde:{keykeep=KEY_NUM8;break;}
  54   5            case 0xee:{keykeep=KEY_NUM7;break;}
  55   5            default:
C51 COMPILER V7.01  KEY                                                                    08/21/2009 20:36:18 PAGE 2   

  56   5      
  57   5                 break;
  58   5             }
  59   4            } 
  60   3           k = _crol_(k,1);//移位，进入下一行扫描
  61   3          }while(k !=0xef);//超过范围退出    
  62   2        }
  63   1      
  64   1       P1 = 0xff;l9=0;  //第五列如下
  65   1         k = P1;
  66   1        if(k != 0xff)
  67   1           {
  68   2           switch(P1)
  69   2              {          //第五行
  70   3              case 0xf7:{keykeep=KEY_BTN1; break;}
  71   3              case 0xfb:{keykeep=KEY_BTN2;break;}
  72   3              case 0xfd:{keykeep=KEY_BTN3; break;}
  73   3              case 0xfe:{keykeep=KEY_BTN4;break;}
  74   3                  default:
  75   3                  break;
  76   3                  }   
  77   2                }   
  78   1          P1 = 0x0f;l9=0;      
  79   1       }  
  80            
  81          /**************************主程序********************************/
  82          void Key_Init()
  83          {
  84   1              KEYBJ2 = 0;                       //key down event
  85   1              keycount = 0;
  86   1              keykeep = KEY_INVALID;
  87   1          P1 = 0x0f;l9=0;      
  88   1      }
  89          void key_debug(char* buf)
  90          {
  91   1              if(KEYBJ2)
  92   1                      sprintf(buf,"1,%i,%c",keycount,keykeep);
  93   1              else
  94   1                      sprintf(buf,"0,%i,%c",keycount,keykeep);
  95   1      }
  96          
  97          void Key_Scan()
  98          {
  99   1              uchar k;
 100   1              if(KEYBJ2 == 0){
 101   2                      if(kbit == 0)
 102   2                      {
 103   3                              KEYBJ2 = 1;
 104   3                              keycount = 0;
 105   3                      }
 106   2                      return;
 107   2              }
 108   1      
 109   1                      k = keykeep;
 110   1                      keykeep = KEY_INVALID;
 111   1                      decode_key(); //decode the key
 112   1                      if(keycount == 0) //initial decode
 113   1                      {
 114   2                              if(keykeep == KEY_INVALID) //invalid key
 115   2                              {
 116   3                                      KEYBJ2 = 0;
 117   3                                      P1 = 0x0f;l9=0;  
C51 COMPILER V7.01  KEY                                                                    08/21/2009 20:36:18 PAGE 3   

 118   3                                      return;
 119   3                              }
 120   2                      }
 121   1                      if(keykeep == KEY_INVALID) //key up event found
 122   1                      {
 123   2                              KEYBJ2 = 0;
 124   2                              P1 = 0x0f;l9=0;
 125   2      
 126   2                              if(keycount >= KEYTIMEOUT)
 127   2                                      key = k;
 128   2                              return;
 129   2                      }
 130   1                      keycount++;
 131   1                      if(keycount > 128)
 132   1                              keycount = 1;
 133   1              return;
 134   1      
 135   1      }
 136          sbit sca_clk = P0^7;
 137          sbit sca_dat = P0^6;
 138          void display_buttons(uchar btn_pos,uchar btn_val)   //74164串行移位一个数
 139          {
 140   1               uchar i=0;
 141   1                       uchar c= 0;
 142   1                       if(btn_val){
 143   2                               switch(btn_pos)
 144   2                               {
 145   3                                      case KEY_BTN1:  c = c | 0x11;break;
 146   3                                      case KEY_BTN2:  c = c | 0x22;break;
 147   3                                      case KEY_BTN3:  c = c | 0x44;break;
 148   3                                      case KEY_BTN4:  c = c | 0x88;break;
 149   3                                      default:
 150   3                                              return;
 151   3                              }
 152   2                      }else{
 153   2                              switch(btn_pos)
 154   2                              {
 155   3                                      case KEY_BTN1:  c = c & 0xEE;break;
 156   3                                      case KEY_BTN2:  c = c & 0xDD;break;
 157   3                                      case KEY_BTN3:  c = c & 0xBB;break;
 158   3                                      case KEY_BTN4:  c = c & 0x77;break;
 159   3                                      default:
 160   3                                              return;
 161   3                              }
 162   2                      }
 163   1      
 164   1               do{  
 165   2                   if(c&0x01)     
 166   2                       sca_dat=1;
 167   2                   else
 168   2                                       sca_dat=0;
 169   2                           c>>=1;        //数组tabel中的第N个数向右移动一位
 170   2                               _nop_(); _nop_();
 171   2                   sca_clk=0;            //下降沿将数据写入164，拉高时钟端停止，再拉低等待下一次写入
 172   2                   _nop_(); _nop_();
 173   2                               sca_clk=1;
 174   2                                _nop_(); _nop_();
 175   2                   sca_clk=0;
 176   2                                _nop_(); _nop_();
 177   2                   i++;
 178   2                  }
 179   1              while(i<8);
C51 COMPILER V7.01  KEY                                                                    08/21/2009 20:36:18 PAGE 4   

 180   1      }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    521    ----
   CONSTANT SIZE    =     16    ----
   XDATA SIZE       =   ----    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =      3       5
   IDATA SIZE       =   ----    ----
   BIT SIZE         =      1    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
